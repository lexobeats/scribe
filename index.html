<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Roue du Scribe â€” Ã‰quipe</title>
  <style>
    :root {
      --wheel-radius: 260px;         /* âœ… Rayon de la roue dÃ©fini en CSS */
      --accent: #3b82f6;
      --accent-orange: #f59e0b;      /* curseur */
      --bg: #0b1220;
      --panel: #0f172aee;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --success: #10b981;
    }

    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 600px at 20% 10%, #0b1220 0%, #060913 60%, #030712 100%); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }

    .wrap { height: 100%; display: grid; grid-template-rows: 1fr; grid-template-columns: 1fr; }

    /* Titre centrÃ© en haut, avec animation cartoonesque */
    header { position: fixed; top: 8px; left: 0; right: 0; display: flex; justify-content: center; z-index: 5; pointer-events: none; }
    h1 { pointer-events: auto; font-size: clamp(28px, 4.6vw, 54px); margin: 0; letter-spacing: .3px; font-weight: 900; text-shadow: 0 4px 22px rgba(0,0,0,.45); animation: puff 2.4s ease-in-out infinite alternate; }
    @keyframes puff { 0% { transform: scale(0.98); } 100% { transform: scale(1.06); } }

    .wheel-area { position: relative; display: grid; place-items: center; height: 100vh; }

    /* Canvas dimensionnÃ© via le rayon CSS */
    #wheelCanvas { width: calc(var(--wheel-radius) * 2); height: calc(var(--wheel-radius) * 2); display: block; filter: drop-shadow(0 24px 40px rgba(0,0,0,.45)); background: conic-gradient(from 0deg, #0d1324 0 25%, #0a0f1f 0 50%, #0d1324 0 75%, #0a0f1f 0 100%); border-radius: 50%; }

/* Curseur Ã  droite, orange, collÃ© Ã  la roue (0Â°) */
.pointer {
  position: absolute;
  left: calc(50% + var(--wheel-radius) - 2px);
  top: 50%;
  transform: translateY(-50%);
  width: 0; height: 0;
  border-top: 20px solid transparent;
  border-bottom: 20px solid transparent;
  border-right: 30px solid var(--accent-orange);
  filter: drop-shadow(0 6px 14px rgba(0,0,0,.55));
  z-index: 3;
}

    /* Bouton Lancer sous la roue */
    .controls { margin-top: 14px; display: flex; gap: 12px; align-items: center; justify-content: center; }
    .btn { appearance: none; border: 1px solid #1f2a44; background: linear-gradient(180deg, #2563eb, #1d4ed8); color: var(--text); padding: 12px 16px; border-radius: 12px; font-weight: 700; cursor: pointer; transition: transform .06s ease, box-shadow .12s ease, background .2s ease; box-shadow: 0 6px 16px rgba(0,0,0,.35) inset, 0 2px 8px rgba(0,0,0,.25); }
    .btn:hover { transform: translateY(-1px); }
    .btn:active { transform: translateY(1px) scale(.98); }

    /* Panneau d'Ã©dition au milieu droit */
    .editor { position: fixed; top: 50%; left: 16px; transform: translateY(-50%); width: min(520px, 38vw); max-width: 520px; max-height: 70vh; overflow-y: auto; overflow-x: hidden; background: var(--panel); backdrop-filter: blur(8px); border: 1px solid #213052; border-radius: 16px; padding: 12px; box-shadow: 0 14px 44px rgba(0,0,0,.45); z-index: 4; }
    .editor h2 { font-size: 14px; margin: 0 0 8px 0; color: var(--muted); font-weight: 700; letter-spacing: .3px; }

    table { width: 100%; border-collapse: collapse; }
    thead th { text-align: left; font-size: 12px; color: var(--muted); font-weight: 700; padding: 6px 8px; }
    tbody td { padding: 6px 8px; vertical-align: middle; }
    tbody tr { border-top: 1px dashed #22304f; }

    input[type="text"], input[type="date"], input[type="color"] { width: 100%; box-sizing: border-box; background: #0b1222; color: var(--text); border: 1px solid #26324e; padding: 8px 10px; border-radius: 10px; outline: none; }

/* Hauteur harmonisÃ©e pour texte et date */
input[type="text"],
input[type="date"] {
  min-height: 46px;     /* mÃªme hauteur */
  padding-top: 10px;
  padding-bottom: 10px;
  line-height: normal;  /* Ã©vite le rognage du placeholder selon le navigateur */
}


    .color-cell { width: 56px; }
    .swatch { width: 28px; height: 20px; border-radius: 6px; border: 1px solid #233250; box-shadow: inset 0 0 0 1px rgba(255,255,255,.08); cursor: pointer; }
    .chance-cell { width: 84px; font-variant-numeric: tabular-nums; text-align: right; color: #e2e8f0; font-weight: 700; }
    .action-cell { width: 40px; text-align: right; }
    .iconbtn { background: transparent; border: none; color: var(--muted); cursor: pointer; font-size: 18px; line-height: 1; }
    .iconbtn:hover { color: #e2e8f0; }

    .footer-bar { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; align-items: center; background: var(--panel); padding: 10px 12px; border-radius: 999px; border: 1px solid #20304e; box-shadow: 0 14px 44px rgba(0,0,0,.45); font-size: 14px; }

    .winner-badge { font-weight: 800; }
/* Tuile winner plus grande */
#resultBar {
  padding: 16px 20px;    /* plus d'air */
  font-size: 18px;       /* texte plus grand */
}

.winner-text {
  font-weight: 900;
  letter-spacing: .2px;
}

/* Bouton Lancer la roue plus grand */
#spinBtn {
  padding: 16px 22px;
  font-size: 18px;
  border-radius: 14px;
}

    @media (max-width: 980px) { :root { --wheel-radius: 200px; } .editor { right: 8px; width: min(92vw, 520px); } }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Roue du Scribe</h1>
    </header>

    <main class="wheel-area">
      <div class="pointer" aria-hidden="true"></div>
      <canvas id="wheelCanvas" width="800" height="800" aria-label="Roue de sÃ©lection du scribe" role="img"></canvas>
      <div class="controls">
        <button id="spinBtn" class="btn" aria-label="Lancer la roue (Espace)">ðŸŽ¯ Lancer la roue !</button>
      </div>
    </main>

<div class="footer-bar" id="resultBar" style="display:none">
  <div id="winnerText" class="winner-text" role="status" aria-live="polite"></div>
</div>

  <!-- Ã‰diteur : tableau au milieu droit, colonnes Nom | Dernier passage | Couleur | % | Ã— -->
  <aside class="editor" aria-label="Ã‰diteur des participants">
    <h2>Participants &amp; derniÃ¨res dates</h2>
    <table>
      <thead>
        <tr>
          <th style="width:44%">Nom</th>
          <th style="width:28%">Dernier passage</th>
          <th class="color-cell">Couleur</th>
          <th class="chance-cell">% chance</th>
          <th class="action-cell"></th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
    <div style="display:flex; gap:8px; margin-top:10px;">
      <button id="addRowBtn" class="btn" title="Ajouter un participant">+ Ajouter</button>
      <button id="importCsvBtn" class="btn" title="Importer depuis un CSV (;)">ðŸ“¥ Importer CSV</button>
      <button id="exportCsvBtn" class="btn" title="Exporter en CSV (;)">ðŸ“¤ Exporter CSV</button>
      <input id="importFile" type="file" accept=".csv,text/csv" style="display:none" />
    </div>
  </aside>

  <script>
    /*********************************************************
     * Roue du Scribe â€” logique (v2)
     * - Curseur Ã  DROITE (0Â°)
     * - Pourcentages affichÃ©s dans le tableau (lecture seule)
     * - Couleur par personne (modifiable via color picker)
     *********************************************************/

    const canvas = document.getElementById('wheelCanvas');
    const ctx = canvas.getContext('2d');
    const spinBtn = document.getElementById('spinBtn');
    const rowsTbody = document.getElementById('rows');
    const addRowBtn = document.getElementById('addRowBtn');
    const importCsvBtn = document.getElementById('importCsvBtn');
    const exportCsvBtn = document.getElementById('exportCsvBtn');
    const importFileInput = document.getElementById('importFile');


    const resultBar = document.getElementById('resultBar');
const winnerTextEl = document.getElementById('winnerText');
    const pointerEl = document.querySelector('.pointer');


    // Rayon dÃ©rivÃ© du CSS (en px)
    function getCssRadius() {
      const v = getComputedStyle(document.documentElement).getPropertyValue('--wheel-radius').trim();
      const m = v.match(/([\d.]+)px/);
      const r = m ? parseFloat(m[1]) : 260;
      return r;
    }

    function resizeCanvasToRadius() {
      const r = getCssRadius();
      const size = r * 2;
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
      canvas.width = Math.round(size * dpr);
      canvas.height = Math.round(size * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    const STORAGE_KEY = 'scribe-wheel:v2';

    /** @type {{name:string,last:string,color?:string}[]} */
    let people = [];

    // Couleurs par dÃ©faut (si non dÃ©finies personellement)
    function defaultColor(i, n) {
      const h = Math.round((360/n) * i + 8) % 360;
      const s = 68 + Math.round(12*Math.sin(i));
      const l = 48 + Math.round(5*Math.cos(i));
      return `hsl(${h} ${s}% ${l}%)`;
    }

    function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify({ people })); }

    function load() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        try { const obj = JSON.parse(raw); if (Array.isArray(obj.people)) people = obj.people; } catch {}
      }
      if (!people.length) {
        people = [ { name:'Alice', last:'', color:'' }, { name:'BenoÃ®t', last:'', color:'' }, { name:'ChloÃ©', last:'', color:'' } ];
      }
    }

    // Outils temps / poids
    const DAY = 24*60*60*1000;
    function daysSince(iso) {
      if (!iso) return null; // null => traitÃ© comme maximum
      const d = new Date(iso + 'T00:00:00');
      if (isNaN(d)) return null;
      const now = new Date();
      const diff = Math.floor((now - d) / DAY);
      return Math.max(0, diff);
    }
    function weightFor(iso, maxBoostDays) {
      const ds = daysSince(iso);
      if (ds === null) return maxBoostDays + 30; // jamais / vide => gros bonus
      return Math.max(1, ds);
    }

    // Parts & chances
    let slices = []; // { name,startDeg,endDeg,midDeg,color,weight,percent }
    function rebuildSlices() {
      const dayVals = people.map(p => daysSince(p.last)).filter(v => v !== null);
      const maxDays = dayVals.length ? Math.max(...dayVals) : 30;
      const weights = people.map(p => weightFor(p.last, maxDays));
      const total = weights.reduce((a,b)=>a+b, 0) || 1;

      let cursor = -90; // on garde le 0Â° de dÃ©part en haut pour le dessin
      slices = people.map((p, i) => {
        const w = weights[i];
        const ang = (w / total) * 360;
        const startDeg = cursor;
        const endDeg = cursor + ang;
        cursor = endDeg;
        const percent = (w / total) * 100;
        return { name: p.name || 'â€”', startDeg, endDeg, midDeg: startDeg + ang/2, color: (p.color && p.color.trim()) || defaultColor(i, people.length), weight: w, percent };
      });
    }

    // Dessin
    let rotationDeg = 0;
    function drawWheel() {
      const r = getCssRadius();
      const cx = r, cy = r;
      ctx.clearRect(0,0,canvas.width,canvas.height);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate((Math.PI/180) * rotationDeg);

      // Anneau extÃ©rieur
      ctx.beginPath(); ctx.arc(0,0, r, 0, Math.PI*2); ctx.fillStyle = '#0b1328'; ctx.fill();

      // Secteurs + labels
      slices.forEach((s) => {
        const a0 = (Math.PI/180) * s.startDeg;
        const a1 = (Math.PI/180) * s.endDeg;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, r-8, a0, a1); ctx.closePath();
        ctx.fillStyle = s.color; ctx.fill();

        // sÃ©parateurs
        ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth = 1.25; ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, r-8, a0, a1); ctx.stroke();

// label (texte noir avec contour blanc, sans bandeau)
ctx.save();
const mid = (a0 + a1)/2;
ctx.rotate(mid);
ctx.textAlign = 'right';
ctx.textBaseline = 'middle';
ctx.font = '800 14px system-ui, sans-serif';

const label = (s.name || 'â€”').toUpperCase();

// contour blanc
ctx.lineJoin = 'round';
ctx.miterLimit = 2;
ctx.lineWidth = 3;
ctx.strokeStyle = 'rgba(255,255,255,0.95)';

// remplissage noir
ctx.fillStyle = '#000000';

// position: 24px Ã  l'intÃ©rieur du bord
ctx.strokeText(label, r - 24, 0);
ctx.fillText(label,  r - 24, 0);

ctx.restore();

      });

      // Moyeu
      ctx.beginPath(); ctx.arc(0,0, 30, 0, Math.PI*2); ctx.fillStyle = '#111827'; ctx.fill();
      ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255,255,255,.15)'; ctx.stroke();

      ctx.restore();

      // LiserÃ© extÃ©rieur
      ctx.save(); ctx.translate(cx, cy); ctx.beginPath(); ctx.arc(0,0, r-2, 0, Math.PI*2); ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(255,255,255,.18)'; ctx.stroke(); ctx.restore();
    }

    // Vainqueur : curseur Ã  DROITE => angle 0Â°
    function winnerForRotation(rotDeg) {
      let pointer = (0 - rotDeg) % 360; // droite
      if (pointer < 0) pointer += 360;
      return slices.find((s) => inRange(pointer, s.startDeg, s.endDeg)) || slices[slices.length-1];
    }
    function inRange(a, start, end) { const norm = x => (x%360+360)%360; a = norm(a); start = norm(start); end = norm(end); if (start < end) return a >= start && a < end; return a >= start || a < end; }

    // Animation de spin
    let animId = null;
    function spin() {
      if (!people.length) return;
      resultBar.style.display = 'none';
      const start = performance.now();
      const initial = rotationDeg;
      const target = Math.random() * 360;
      const turns = 6 + Math.floor(Math.random()*3);
      const totalDelta = turns*360 + target;
      const duration = 5200 + Math.random()*1400;

      cancelAnimationFrame(animId);
      animId = requestAnimationFrame(function step(t){
        const p = Math.min(1, (t - start)/duration);
        const ease = backOut(p);
        rotationDeg = initial + totalDelta * ease;
        drawWheel();
        if (p < 1) { animId = requestAnimationFrame(step); }
        else { const w = winnerForRotation(rotationDeg); showWinner(w.name); flashSlice(w); }
      });
    }
    function backOut(t) { const c1 = 1.70158; const c3 = c1 + 1; return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2); }

    function flashSlice(slice) {
      const r = getCssRadius();
      const start = performance.now();
      function step(t){
        const p = Math.min(1, (t - start)/1000);
        drawWheel();
        ctx.save(); ctx.translate(r, r); ctx.rotate((Math.PI/180) * rotationDeg);
        const a0 = (Math.PI/180) * slice.startDeg; const a1 = (Math.PI/180) * slice.endDeg;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, r-6, a0, a1); ctx.closePath();
        ctx.fillStyle = 'rgba(255,255,255,' + (0.25 + 0.25*Math.sin(p*6*Math.PI)) + ')'; ctx.fill();
        ctx.restore();
        if (p < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

function showWinner(name){
  const n = name || 'â€”';
  winnerTextEl.textContent = `Le prochain scribe est Â« ${n} Â», fÃ©licitations ! ðŸŽ‰`;
  resultBar.style.display = 'flex';
}


    // --- Tableau ---
    function renderTable() {
      rowsTbody.innerHTML = '';
      // recalculer les pourcentages pour affichage
      const dayVals = people.map(p => daysSince(p.last)).filter(v => v !== null);
      const maxDays = dayVals.length ? Math.max(...dayVals) : 30;
      const weights = people.map(p => weightFor(p.last, maxDays));
      const total = weights.reduce((a,b)=>a+b, 0) || 1;

      people.forEach((p, idx) => {
        const tr = document.createElement('tr');

        // Nom
        const tdName = document.createElement('td');
        const inpName = document.createElement('input'); inpName.type = 'text'; inpName.value = p.name; inpName.placeholder = 'Nom';
        inpName.addEventListener('input', () => { p.name = inpName.value; onDataChange(); });
        tdName.appendChild(inpName);

        // Dernier passage
        const tdDate = document.createElement('td');
        const inpDate = document.createElement('input'); inpDate.type = 'date'; inpDate.value = p.last || '';
        inpDate.addEventListener('change', () => { p.last = inpDate.value; onDataChange(); });
        tdDate.appendChild(inpDate);

        // Couleur (swatch + color input)
        const tdColor = document.createElement('td'); tdColor.className = 'color-cell';
        const sw = document.createElement('div'); sw.className = 'swatch'; sw.style.background = (p.color && p.color.trim()) || defaultColor(idx, people.length);
        const colorInput = document.createElement('input'); colorInput.type = 'color'; colorInput.value = toHexColor(sw.style.background);
        colorInput.style.display = 'none';
        sw.addEventListener('click', () => colorInput.click());
        colorInput.addEventListener('input', () => { p.color = colorInput.value; sw.style.background = p.color; onDataChange(); });
        tdColor.appendChild(sw); tdColor.appendChild(colorInput);

        // % chance (lecture seule)
        const tdPct = document.createElement('td'); tdPct.className = 'chance-cell';
        const w = weights[idx]; const pct = (w / total) * 100; tdPct.textContent = pct.toFixed(1) + '%';

        // Supprimer
        const tdAct = document.createElement('td'); tdAct.className = 'action-cell';
        const del = document.createElement('button'); del.className = 'iconbtn'; del.title = 'Supprimer'; del.innerHTML = 'Ã—';
        del.addEventListener('click', () => { people.splice(idx,1); onDataChange(); renderTable(); });
        tdAct.appendChild(del);

        tr.appendChild(tdName); tr.appendChild(tdDate); tr.appendChild(tdColor); tr.appendChild(tdPct); tr.appendChild(tdAct);
        rowsTbody.appendChild(tr);
      });
    }

    function toHexColor(cssColor){
      // Convertit hsl()/rgb() Ã©ventuels en #rrggbb pour input[type=color]
      const c = document.createElement('canvas'); const x = c.getContext('2d'); x.fillStyle = cssColor; const computed = x.fillStyle; // normalisÃ© en rgb(a)
      const m = computed.match(/rgb[a]?\((\d+),\s*(\d+),\s*(\d+)/i); if(!m) return '#ffffff';
      const r = Number(m[1]).toString(16).padStart(2,'0'); const g = Number(m[2]).toString(16).padStart(2,'0'); const b = Number(m[3]).toString(16).padStart(2,'0');
      return `#${r}${g}${b}`;
    }

    function onDataChange() { rebuildSlices(); save(); drawWheel(); renderTable(); }

    addRowBtn.addEventListener('click', () => { people.push({ name: '', last: '', color: '' }); onDataChange(); });

    window.addEventListener('keydown', (e) => { if (e.code === 'Space') { e.preventDefault(); spin(); } });
    spinBtn.addEventListener('click', spin);
    exportCsvBtn.addEventListener('click', exportCSV);
    importCsvBtn.addEventListener('click', () => importFileInput.click());
    importFileInput.addEventListener('change', handleImportCSV);

    // Boot
    resizeCanvasToRadius();
    load();
    rebuildSlices();
    drawWheel();
    renderTable();
    positionPointer();
    window.addEventListener('resize', () => { resizeCanvasToRadius(); drawWheel(); positionPointer(); });


    /* === Import/Export CSV (sÃ©parateur ;) === */

function exportCSV() {
  const header = ['Nom', 'Dernier passage', 'Couleur'];
  const rows = people.map(p => [
    p.name || '',
    p.last || '',
    (p.color && p.color.trim()) || ''
  ]);
  const csv = [header, ...rows].map(r => r.map(csvEscape).join(';')).join('\r\n');

  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'participants.csv';
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
}

function csvEscape(val) {
  val = String(val ?? '');
  return /[;"\n\r]/.test(val) ? '"' + val.replace(/"/g, '""') + '"' : val;
}

function handleImportCSV(e) {
  const file = e.target.files && e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    try {
      const text = String(reader.result);
      const rows = parseCSV(text, ';');
      if (!rows.length) return;

      let startIdx = 0;
      let nameIdx = 0, dateIdx = 1, colorIdx = 2;

      // DÃ©tection d'en-tÃªtes Ã©ventuels
      const header = rows[0].map(h => h.trim().toLowerCase());
      if (header.some(h => ['nom', 'dernier passage', 'couleur'].some(k => h.includes(k)))) {
        startIdx = 1;
        nameIdx = header.findIndex(h => h.startsWith('nom'));       if (nameIdx < 0) nameIdx = 0;
        dateIdx = header.findIndex(h => h.startsWith('dernier'));   if (dateIdx < 0) dateIdx = 1;
        colorIdx = header.findIndex(h => h.startsWith('couleur'));  if (colorIdx < 0) colorIdx = 2;
      }

      const imported = [];
      for (let i = startIdx; i < rows.length; i++) {
        const r = rows[i];
        if (!r || !r.length) continue;
        const name = (r[nameIdx] || '').trim();
        const last = (r[dateIdx] || '').trim();
        const color = (r[colorIdx] || '').trim();
        if (!name) continue;
        imported.push({ name, last: normalizeDate(last), color });
      }

      if (imported.length) {
        people = imported;
        onDataChange();
        renderTable();
      }
    } finally {
      importFileInput.value = '';
    }
  };
  reader.readAsText(file, 'utf-8');
}

// Parse CSV simple avec guillemets et sÃ©parateur configurable (par dÃ©faut ;)
function parseCSV(text, delimiter = ';') {
  const rows = [];
  let cur = '', row = [];
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (inQuotes) {
      if (ch === '"') {
        if (text[i + 1] === '"') { cur += '"'; i++; }
        else { inQuotes = false; }
      } else {
        cur += ch;
      }
    } else {
      if (ch === '"') {
        inQuotes = true;
      } else if (ch === delimiter) {
        row.push(cur); cur = '';
      } else if (ch === '\n') {
        row.push(cur); rows.push(row); row = []; cur = '';
      } else if (ch === '\r') {
        // ignore CR
      } else {
        cur += ch;
      }
    }
  }
  if (cur.length > 0 || row.length > 0) {
    row.push(cur); rows.push(row);
  }
  return rows;
}

// Normalise quelques formats de date vers YYYY-MM-DD (vide si non reconnu)
function normalizeDate(s) {
  if (!s) return '';
  const iso = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (iso) return s;
  const fr = s.match(/^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{4})$/);
  if (fr) {
    const d = String(fr[1]).padStart(2, '0');
    const m = String(fr[2]).padStart(2, '0');
    const y = fr[3];
    return `${y}-${m}-${d}`;
  }
  return '';
}

function positionPointer() {
  const areaRect = document.querySelector('.wheel-area').getBoundingClientRect();
  const canvasRect = canvas.getBoundingClientRect();
  const triangleWidth = 30; // doit correspondre au border-right ci-dessus

  // Tip de la flÃ¨che au bord droit de la roue
  pointerEl.style.left = (canvasRect.right - areaRect.left - triangleWidth) + 'px';
  // Alignement vertical sur le centre exact du canvas
  pointerEl.style.top = (canvasRect.top - areaRect.top + canvasRect.height / 2) + 'px';
  pointerEl.style.transform = 'translateY(-50%)';
}

    // Polyfill roundRect
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (typeof r === 'number') r = {tl:r, tr:r, br:r, bl:r};
        const {tl=0,tr=0,br=0,bl=0} = r||{};
        this.beginPath(); this.moveTo(x+tl, y); this.lineTo(x+w-tr, y); this.quadraticCurveTo(x+w, y, x+w, y+tr);
        this.lineTo(x+w, y+h-br); this.quadraticCurveTo(x+w, y+h, x+w-br, y+h);
        this.lineTo(x+bl, y+h); this.quadraticCurveTo(x, y+h, x, y+h-bl);
        this.lineTo(x, y+tl); this.quadraticCurveTo(x, y, x+tl, y); this.closePath(); return this;
      }
    }
  </script>
</body>
</html>
