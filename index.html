<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Roue du Scribe â€” Ã‰quipe</title>
  <style>
    :root {
      /* Ajustez seulement ces variables pour changer la taille/apparence globale */
      --wheel-radius: 260px;           /* âœ… Rayon de la roue dÃ©fini en CSS, pas dans le JS */
      --accent: #3b82f6;
      --bg: #0b1220;
      --panel: #0f172aee;              /* panneau semi-opaque */
      --text: #e5e7eb;
      --muted: #94a3b8;
      --success: #10b981;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 600px at 20% 10%, #0b1220 0%, #060913 60%, #030712 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    .wrap {
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
      grid-template-columns: 1fr;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      gap: 12px;
    }

    h1 {
      font-size: clamp(18px, 2.2vw, 26px);
      margin: 0;
      letter-spacing: 0.2px;
      font-weight: 700;
    }

    .wheel-area {
      position: relative;
      display: grid;
      place-items: center;
      padding: 24px;
    }

    /* Canvas dimensionnÃ© via le rayon CSS */
    #wheelCanvas {
      width: calc(var(--wheel-radius) * 2);
      height: calc(var(--wheel-radius) * 2);
      display: block;
      filter: drop-shadow(0 24px 40px rgba(0,0,0,.45));
      background: conic-gradient(from 0deg, #0d1324 0 25%, #0a0f1f 0 50%, #0d1324 0 75%, #0a0f1f 0 100%);
      border-radius: 50%;
    }

    /* Pointeur fixe Ã  0Â° (haut) */
    .pointer {
      position: absolute;
      top: calc(50% - var(--wheel-radius) - 10px);
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 16px solid transparent;
      border-right: 16px solid transparent;
      border-bottom: 22px solid var(--accent);
      filter: drop-shadow(0 4px 8px rgba(0,0,0,.45));
    }

    /* Boutons */
    .btn {
      appearance: none;
      border: 1px solid #1f2a44;
      background: linear-gradient(180deg, #1e293b, #0f172a);
      color: var(--text);
      padding: 12px 16px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .06s ease, box-shadow .12s ease, background .2s ease;
      box-shadow: 0 6px 16px rgba(0,0,0,.35) inset, 0 2px 8px rgba(0,0,0,.25);
    }
    .btn:hover { transform: translateY(-1px); }
    .btn:active { transform: translateY(1px) scale(.98); }

    .btn-primary { border-color: #2951b3; background: linear-gradient(180deg, #2563eb, #1d4ed8); }
    .btn-success { border-color: #0f5f4b; background: linear-gradient(180deg, #10b981, #059669); }
    .btn-ghost { background: transparent; border-color: #334155; color: var(--muted); }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      padding-bottom: 8px;
    }

    /* Panneau d'Ã©dition en bas Ã  gauche */
    .editor {
      position: fixed;
      bottom: 16px;
      left: 16px;
      max-width: min(520px, 92vw);
      background: var(--panel);
      backdrop-filter: blur(8px);
      border: 1px solid #213052;
      border-radius: 16px;
      padding: 12px 12px 8px 12px;
      box-shadow: 0 14px 44px rgba(0,0,0,.45);
    }

    .editor h2 {
      font-size: 14px;
      margin: 0 0 8px 0;
      color: var(--muted);
      font-weight: 700;
      letter-spacing: .3px;
    }

    table { width: 100%; border-collapse: collapse; }
    thead th { text-align: left; font-size: 12px; color: var(--muted); font-weight: 700; padding: 6px 8px; }
    tbody td { padding: 6px 8px; }

    tbody tr { border-top: 1px dashed #22304f; }

    input[type="text"], input[type="date"] {
      width: 100%;
      box-sizing: border-box;
      background: #0b1222;
      color: var(--text);
      border: 1px solid #26324e;
      padding: 8px 10px;
      border-radius: 10px;
      outline: none;
    }

    .action-cell { width: 40px; text-align: right; }
    .iconbtn {
      background: transparent; border: none; color: var(--muted); cursor: pointer; font-size: 18px; line-height: 1;
    }
    .iconbtn:hover { color: #e2e8f0; }

    .footer-bar {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      align-items: center;
      background: var(--panel);
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid #20304e;
      box-shadow: 0 14px 44px rgba(0,0,0,.45);
      font-size: 14px;
    }

    .winner-badge { font-weight: 700; }

    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }

    /* Responsive */
    @media (max-width: 680px) {
      :root { --wheel-radius: 200px; }
      .editor { left: 8px; right: 8px; max-width: unset; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Roue du Scribe</h1>
      <div class="controls">
        <button id="spinBtn" class="btn btn-primary" aria-label="Lancer la roue (Espace)">ðŸŽ¯ Lancer</button>
        <button id="shuffleColorsBtn" class="btn btn-ghost" title="RegÃ©nÃ©rer les couleurs">Couleurs</button>
        <button id="resetBtn" class="btn btn-ghost" title="RÃ©initialiser les donnÃ©es">RÃ©initialiser</button>
      </div>
    </header>

    <main class="wheel-area">
      <div class="pointer" aria-hidden="true"></div>
      <canvas id="wheelCanvas" width="800" height="800" aria-label="Roue de sÃ©lection du scribe" role="img"></canvas>
    </main>

    <div class="footer-bar" id="resultBar" style="display:none">
      <span class="winner-badge">Scribe :</span>
      <span id="winnerName">â€”</span>
      <button id="confirmWinnerBtn" class="btn btn-success" title="Marquer comme passÃ© aujourd'hui">Valider</button>
      <button id="closeResultBtn" class="btn btn-ghost" title="Fermer">Fermer</button>
    </div>
  </div>

  <!-- Panneau d'Ã©dition (bas-gauche) : tableau Ã  2 colonnes (Nom, Dernier passage) avec + et Ã— -->
  <aside class="editor" aria-label="Ã‰diteur des participants">
    <h2>Participants &amp; derniÃ¨res dates</h2>
    <table>
      <thead>
        <tr>
          <th style="width:52%">Nom</th>
          <th style="width:38%">Dernier passage</th>
          <th class="action-cell"></th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
    <div style="display:flex; gap:8px; margin-top:10px;">
      <button id="addRowBtn" class="btn" title="Ajouter un participant">+ Ajouter</button>
      <button id="exportBtn" class="btn btn-ghost" title="Exporter en JSON">Exporter</button>
      <input id="importInput" type="file" accept="application/json" style="display:none"/>
      <button id="importBtn" class="btn btn-ghost" title="Importer un JSON">Importer</button>
    </div>
  </aside>

  <script>
    /*********************************************************
     * Roue du Scribe â€” logique
     * - Parts proportionnelles au nombre de jours Ã©coulÃ©s depuis
     *   le dernier passage (champ vide = boost maximum)
     * - Pointeur fixe Ã  0Â° (haut). Vainqueur = secteur sous le pointeur
     *********************************************************/

    const canvas = document.getElementById('wheelCanvas');
    const ctx = canvas.getContext('2d');
    const spinBtn = document.getElementById('spinBtn');
    const resetBtn = document.getElementById('resetBtn');
    const shuffleColorsBtn = document.getElementById('shuffleColorsBtn');
    const rowsTbody = document.getElementById('rows');
    const addRowBtn = document.getElementById('addRowBtn');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importInput = document.getElementById('importInput');

    const resultBar = document.getElementById('resultBar');
    const winnerNameEl = document.getElementById('winnerName');
    const confirmWinnerBtn = document.getElementById('confirmWinnerBtn');
    const closeResultBtn = document.getElementById('closeResultBtn');

    // Rayon dÃ©rivÃ© du CSS (en px). On prend la valeur calculÃ©e de la variable.
    function getCssRadius() {
      const v = getComputedStyle(document.documentElement).getPropertyValue('--wheel-radius').trim();
      const m = v.match(/([\d.]+)px/);
      const r = m ? parseFloat(m[1]) : 260;
      return r;
    }

    // Adapter le canvas (hiDPI) Ã  partir du rayon CSS
    function resizeCanvasToRadius() {
      const r = getCssRadius();
      const size = r * 2;
      // multiplier pour retina
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
      canvas.width = Math.round(size * dpr);
      canvas.height = Math.round(size * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // --- ModÃ¨le de donnÃ©es ---
    const STORAGE_KEY = 'scribe-wheel:v1';

    /** @type {{name:string,last:string}[]} */
    let people = [];

    // Couleurs de secteurs
    let colors = [];
    function regenColors(n) {
      // Palette variÃ©e en HSL
      colors = Array.from({length:n}, (_,i) => {
        const h = Math.round((360/n) * i + 8) % 360;
        const s = 68 + Math.round(12*Math.sin(i));
        const l = 48 + Math.round(5*Math.cos(i));
        return `hsl(${h} ${s}% ${l}%)`;
      });
    }

    function save() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ people, colors }));
    }

    function load() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        try {
          const obj = JSON.parse(raw);
          if (Array.isArray(obj.people)) people = obj.people;
          if (Array.isArray(obj.colors)) colors = obj.colors;
        } catch {}
      }
      if (!people.length) {
        // Trois lignes vierges par dÃ©faut
        people = [
          { name: 'Alice', last: '' },
          { name: 'BenoÃ®t', last: '' },
          { name: 'ChloÃ©', last: '' },
        ];
      }
      regenColors(people.length);
    }

    // Outils temps
    const DAY = 24*60*60*1000;
    function daysSince(iso) {
      if (!iso) return null; // null => traitÃ©e comme maximum
      const d = new Date(iso + 'T00:00:00');
      if (isNaN(d)) return null;
      const now = new Date();
      const diff = Math.floor((now - d) / DAY);
      return Math.max(0, diff);
    }

    function weightFor(iso, maxBoostDays) {
      const ds = daysSince(iso);
      if (ds === null) return maxBoostDays + 30; // jamais / vide => gros bonus
      return Math.max(1, ds);
    }

    // Construire les parts de roue Ã  partir des poids
    let slices = []; // { name, startDeg, endDeg, midDeg }
    function rebuildSlices() {
      // Calcul du boost max (ex: max(days)+10) pour traiter les vides
      const dayVals = people.map(p => daysSince(p.last)).filter(v => v !== null);
      const maxDays = dayVals.length ? Math.max(...dayVals) : 30;
      const weights = people.map(p => weightFor(p.last, maxDays));
      const total = weights.reduce((a,b)=>a+b, 0) || 1;

      let cursor = -90; // top = -90Â°
      slices = people.map((p, i) => {
        const ang = (weights[i] / total) * 360;
        const startDeg = cursor;
        const endDeg = cursor + ang;
        cursor = endDeg;
        return { name: p.name || 'â€”', startDeg, endDeg, midDeg: startDeg + ang/2 };
      });
    }

    // Dessiner la roue
    let rotationDeg = 0; // rotation appliquÃ©e au dessin
    function drawWheel() {
      const r = getCssRadius();
      const cx = r, cy = r;
      ctx.clearRect(0,0,canvas.width,canvas.height);

      ctx.save();
      // DÃ©placer l'origine au centre et appliquer la rotation globale
      ctx.translate(cx, cy);
      ctx.rotate((Math.PI/180) * rotationDeg);

      // Anneau extÃ©rieur
      ctx.beginPath();
      ctx.arc(0,0, r, 0, Math.PI*2);
      ctx.fillStyle = '#0b1328';
      ctx.fill();

      // Secteurs
      slices.forEach((s, i) => {
        const a0 = (Math.PI/180) * s.startDeg;
        const a1 = (Math.PI/180) * s.endDeg;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0, r-8, a0, a1);
        ctx.closePath();
        ctx.fillStyle = colors[i % colors.length] || '#334155';
        ctx.fill();

        // Traits sÃ©parateurs
        ctx.strokeStyle = 'rgba(255,255,255,.08)';
        ctx.lineWidth = 1.25;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0, r-8, a0, a1);
        ctx.stroke();

        // LibellÃ©s
        ctx.save();
        const mid = (a0 + a1)/2;
        ctx.rotate(mid);
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'rgba(0,0,0,.75)';
        ctx.font = '700 14px system-ui, sans-serif';
        const label = (s.name || 'â€”').toUpperCase();
        // Bandeau label
        ctx.beginPath();
        ctx.roundRect( -16, -22, r-60, 28, 10 );
        ctx.fillStyle = 'rgba(255,255,255,.82)';
        ctx.fill();
        // Texte
        ctx.fillStyle = '#0b1220';
        ctx.fillText(label, r-72,  -8);
        ctx.restore();
      });

      // Moyeu
      ctx.beginPath();
      ctx.arc(0,0, 30, 0, Math.PI*2);
      ctx.fillStyle = '#111827';
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(255,255,255,.15)';
      ctx.stroke();

      ctx.restore();

      // LiserÃ© extÃ©rieur
      ctx.save();
      ctx.translate(cx, cy);
      ctx.beginPath();
      ctx.arc(0,0, r-2, 0, Math.PI*2);
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(255,255,255,.18)';
      ctx.stroke();
      ctx.restore();
    }

    // Trouver vainqueur pour un angle de rotation donnÃ©
    function winnerForRotation(rotDeg) {
      // angle du pointeur dans le repÃ¨re de la roue
      let pointer = (-90 - rotDeg) % 360; // top
      if (pointer < 0) pointer += 360;
      return slices.find((s) => inRange(pointer, s.startDeg, s.endDeg)) || slices[slices.length-1];
    }

    function inRange(a, start, end) {
      // start <= a < end, en gÃ©rant les angles nÃ©gatifs / wrap
      const norm = x => (x%360+360)%360;
      a = norm(a); start = norm(start); end = norm(end);
      if (start < end) return a >= start && a < end;
      return a >= start || a < end;
    }

    // Animation de spin (avec suspense)
    let animId = null;
    function spin() {
      if (!people.length) return;
      resultBar.style.display = 'none';
      const start = performance.now();
      const initial = rotationDeg;
      // but alÃ©atoire dans [0,360)
      const target = Math.random() * 360;
      // tours complets pour le suspense
      const turns = 6 + Math.floor(Math.random()*3); // 6 Ã  8 tours
      const totalDelta = turns*360 + target;
      const duration = 5200 + Math.random()*1400; // ms

      cancelAnimationFrame(animId);
      animId = requestAnimationFrame(function step(t){
        const p = Math.min(1, (t - start)/duration);
        // easing cubic-out avec un lÃ©ger dÃ©passement (backOut)
        const ease = backOut(p);
        rotationDeg = initial + totalDelta * ease;
        drawWheel();
        if (p < 1) {
          animId = requestAnimationFrame(step);
        } else {
          // Afficher le rÃ©sultat
          const w = winnerForRotation(rotationDeg);
          showWinner(w.name);
          flashSlice(w);
        }
      });
    }

    function backOut(t) {
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    }

    function flashSlice(slice) {
      // petit surlignage de 1s sur le secteur gagnant
      const r = getCssRadius();
      const start = performance.now();
      function step(t){
        const p = Math.min(1, (t - start)/1000);
        drawWheel();
        ctx.save();
        ctx.translate(r, r);
        ctx.rotate((Math.PI/180) * rotationDeg);
        const a0 = (Math.PI/180) * slice.startDeg;
        const a1 = (Math.PI/180) * slice.endDeg;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0, r-6, a0, a1);
        ctx.closePath();
        ctx.fillStyle = 'rgba(255,255,255,' + (0.25 + 0.25*Math.sin(p*6*Math.PI)) + ')';
        ctx.fill();
        ctx.restore();
        if (p < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    function showWinner(name){
      winnerNameEl.textContent = name || 'â€”';
      resultBar.style.display = 'flex';
    }

    // UI : tableau (2 colonnes) + actions
    function renderTable() {
      rowsTbody.innerHTML = '';
      people.forEach((p, idx) => {
        const tr = document.createElement('tr');

        const tdName = document.createElement('td');
        const inpName = document.createElement('input');
        inpName.type = 'text';
        inpName.value = p.name;
        inpName.placeholder = 'Nom';
        inpName.addEventListener('input', () => { p.name = inpName.value; onDataChange(); });
        tdName.appendChild(inpName);

        const tdDate = document.createElement('td');
        const inpDate = document.createElement('input');
        inpDate.type = 'date';
        inpDate.value = p.last || '';
        inpDate.addEventListener('change', () => { p.last = inpDate.value; onDataChange(); });
        tdDate.appendChild(inpDate);

        const tdAct = document.createElement('td');
        tdAct.className = 'action-cell';
        const del = document.createElement('button');
        del.className = 'iconbtn';
        del.title = 'Supprimer';
        del.innerHTML = 'Ã—';
        del.addEventListener('click', () => { people.splice(idx,1); onDataChange(); renderTable(); });
        tdAct.appendChild(del);

        tr.appendChild(tdName);
        tr.appendChild(tdDate);
        tr.appendChild(tdAct);
        rowsTbody.appendChild(tr);
      });
    }

    function onDataChange() {
      regenColors(people.length);
      rebuildSlices();
      save();
      drawWheel();
    }

    addRowBtn.addEventListener('click', () => {
      people.push({ name: '', last: '' });
      onDataChange();
      renderTable();
    });

    exportBtn.addEventListener('click', () => {
      const blob = new Blob([JSON.stringify({people}, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'roue-scribe-export.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });

    importBtn.addEventListener('click', () => importInput.click());
    importInput.addEventListener('change', () => {
      const file = importInput.files?.[0];
      if (!file) return;
      const fr = new FileReader();
      fr.onload = () => {
        try {
          const data = JSON.parse(String(fr.result));
          if (data && Array.isArray(data.people)) {
            people = data.people.map(p => ({ name: p.name||'', last: p.last||'' }));
            onDataChange();
            renderTable();
          }
        } catch (e) {
          alert('Fichier invalide.');
        }
      };
      fr.readAsText(file);
      importInput.value = '';
    });

    shuffleColorsBtn.addEventListener('click', () => { regenColors(people.length); drawWheel(); save(); });

    resetBtn.addEventListener('click', () => {
      if (!confirm('RÃ©initialiser tous les noms et dates ?')) return;
      people = [ {name:'',last:''} ];
      onDataChange();
      renderTable();
      rotationDeg = 0;
      drawWheel();
    });

    // Valider le vainqueur => met Ã  jour la date Ã  aujourd'hui
    confirmWinnerBtn.addEventListener('click', () => {
      const name = winnerNameEl.textContent;
      const today = new Date().toISOString().slice(0,10);
      const p = people.find(x => (x.name||'â€”') === name);
      if (p) {
        p.last = today;
        onDataChange();
        renderTable();
      }
      resultBar.style.display = 'none';
    });

    closeResultBtn.addEventListener('click', () => { resultBar.style.display = 'none'; });

    // AccessibilitÃ©
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); spin(); }
    });
    spinBtn.addEventListener('click', spin);

    // Boot
    resizeCanvasToRadius();
    load();
    rebuildSlices();
    renderTable();
    drawWheel();

    // Redimensionnement si la variable CSS change (responsive)
    window.addEventListener('resize', () => { resizeCanvasToRadius(); drawWheel(); });

    // Polyfill pour roundRect (Safari anciens)
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (typeof r === 'number') r = {tl:r, tr:r, br:r, bl:r};
        const {tl=0,tr=0,br=0,bl=0} = r||{};
        this.beginPath();
        this.moveTo(x+tl, y);
        this.lineTo(x+w-tr, y);
        this.quadraticCurveTo(x+w, y, x+w, y+tr);
        this.lineTo(x+w, y+h-br);
        this.quadraticCurveTo(x+w, y+h, x+w-br, y+h);
        this.lineTo(x+bl, y+h);
        this.quadraticCurveTo(x, y+h, x, y+h-bl);
        this.lineTo(x, y+tl);
        this.quadraticCurveTo(x, y, x+tl, y);
        this.closePath();
        return this;
      }
    }
  </script>
</body>
</html>
